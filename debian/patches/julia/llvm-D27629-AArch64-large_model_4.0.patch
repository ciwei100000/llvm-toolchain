From 6e7b660ee185445640110c80d80aafd436682fca Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Fri, 9 Dec 2016 15:59:46 -0500
Subject: [PATCH] Fix unwind info relocation with large code model on AArch64

---
 lib/MC/MCObjectFileInfo.cpp                            |  2 ++
 .../AArch64/ELF_ARM64_BE-large-relocations.s           | 18 ++++++++++++++++++
 .../RuntimeDyld/AArch64/ELF_ARM64_large-relocations.s  | 18 ++++++++++++++++++
 3 files changed, 38 insertions(+)
 create mode 100644 test/ExecutionEngine/RuntimeDyld/AArch64/ELF_ARM64_BE-large-relocations.s
 create mode 100644 test/ExecutionEngine/RuntimeDyld/AArch64/ELF_ARM64_large-relocations.s

Index: llvm-toolchain-6.0-6.0.1/lib/MC/MCObjectFileInfo.cpp
===================================================================
--- llvm-toolchain-6.0-6.0.1.orig/lib/MC/MCObjectFileInfo.cpp
+++ llvm-toolchain-6.0-6.0.1/lib/MC/MCObjectFileInfo.cpp
@@ -328,6 +328,8 @@ void MCObjectFileInfo::initELFMCObjectFi
                               dwarf::DW_EH_PE_sdata4
                         : dwarf::DW_EH_PE_absptr;
     break;
+  case Triple::aarch64:
+  case Triple::aarch64_be:
   case Triple::x86_64:
     if (PositionIndependent) {
       PersonalityEncoding =
Index: llvm-toolchain-6.0-6.0.1/test/ExecutionEngine/RuntimeDyld/AArch64/ELF_ARM64_BE-large-relocations.s
===================================================================
--- /dev/null
+++ llvm-toolchain-6.0-6.0.1/test/ExecutionEngine/RuntimeDyld/AArch64/ELF_ARM64_BE-large-relocations.s
@@ -0,0 +1,18 @@
+# RUN: llvm-mc -triple=aarch64_be-none-linux-gnu -code-model=large -filetype=obj -o %T/be-large-reloc.o %s
+# RUN: llvm-rtdyld -triple=aarch64_be-none-linux-gnu -verify -map-section be-large-reloc.o,.eh_frame=0x10000 -map-section be-large-reloc.o,.text=0xffff000000000000 -check=%s %T/be-large-reloc.o
+
+        .text
+        .globl  g
+        .p2align        2
+        .type   g,@function
+g:
+        .cfi_startproc
+        mov      x0, xzr
+        ret
+        .Lfunc_end0:
+        .size   g, .Lfunc_end0-g
+        .cfi_endproc
+
+# Skip the CIE and load the 8 bytes PC begin pointer.
+# Assuming the CIE and the FDE length are both 4 bytes.
+# rtdyld-check: *{8}(section_addr(be-large-reloc.o, .eh_frame) + (*{4}(section_addr(be-large-reloc.o, .eh_frame))) + 0xc) = g - (section_addr(be-large-reloc.o, .eh_frame) + (*{4}(section_addr(be-large-reloc.o, .eh_frame))) + 0xc)
Index: llvm-toolchain-6.0-6.0.1/test/ExecutionEngine/RuntimeDyld/AArch64/ELF_ARM64_large-relocations.s
===================================================================
--- /dev/null
+++ llvm-toolchain-6.0-6.0.1/test/ExecutionEngine/RuntimeDyld/AArch64/ELF_ARM64_large-relocations.s
@@ -0,0 +1,18 @@
+# RUN: llvm-mc -triple=arm64-none-linux-gnu -code-model=large -filetype=obj -o %T/large-reloc.o %s
+# RUN: llvm-rtdyld -triple=arm64-none-linux-gnu -verify -map-section large-reloc.o,.eh_frame=0x10000 -map-section large-reloc.o,.text=0xffff000000000000 -check=%s %T/large-reloc.o
+
+        .text
+        .globl  g
+        .p2align        2
+        .type   g,@function
+g:
+        .cfi_startproc
+        mov      x0, xzr
+        ret
+        .Lfunc_end0:
+        .size   g, .Lfunc_end0-g
+        .cfi_endproc
+
+# Skip the CIE and load the 8 bytes PC begin pointer.
+# Assuming the CIE and the FDE length are both 4 bytes.
+# rtdyld-check: *{8}(section_addr(large-reloc.o, .eh_frame) + (*{4}(section_addr(large-reloc.o, .eh_frame))) + 0xc) = g - (section_addr(large-reloc.o, .eh_frame) + (*{4}(section_addr(large-reloc.o, .eh_frame))) + 0xc)
